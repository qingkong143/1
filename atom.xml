<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>清空•小站</title>
  <icon>https://www.gravatar.com/avatar/73c5346bc645c2ffac4ac4a0e7d37733</icon>
  
  <link href="https://qk.it-02.cf/atom.xml" rel="self"/>
  
  <link href="https://qk.it-02.cf/"/>
  <updated>2023-07-18T04:04:55.892Z</updated>
  <id>https://qk.it-02.cf/</id>
  
  <author>
    <name>清空</name>
    <email>3186708635@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>浅浅写个瑞士军刀</title>
    <link href="https://qk.it-02.cf/posts/15227/"/>
    <id>https://qk.it-02.cf/posts/15227/</id>
    <published>2023-07-18T03:52:28.000Z</published>
    <updated>2023-07-18T04:04:55.892Z</updated>
    
    <content type="html"><![CDATA[<p>闲来无事，于是咱写了个python脚本，实现了瑞士军刀的功能，下面请看代码</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> shlex</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> textwrap</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">execute</span>(<span class="params">cmd</span>):</span><br><span class="line">    cmd = cmd.strip()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> cmd:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    output = subprocess.check_output(shlex.split(cmd),</span><br><span class="line">                                     stderr=subprocess.STDOUT)</span><br><span class="line">    <span class="keyword">return</span> output.decode()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NetCat</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, args, buffer=<span class="literal">None</span></span>):</span><br><span class="line">        self.args = args</span><br><span class="line">        self.buffer = buffer</span><br><span class="line">        self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">        self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.args.listen:</span><br><span class="line">            self.listen()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.send()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">send</span>(<span class="params">self</span>):</span><br><span class="line">        self.socket.connect((self.args.target, self.args.port))</span><br><span class="line">        <span class="keyword">if</span> self.buffer:</span><br><span class="line">            self.socket.send(self.buffer)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                recv_len = <span class="number">1</span></span><br><span class="line">                response = <span class="string">&#x27;&#x27;</span></span><br><span class="line">                <span class="keyword">while</span> recv_len:</span><br><span class="line">                    data = self.socket.recv(<span class="number">4096</span>)</span><br><span class="line">                    recv_len = <span class="built_in">len</span>(data)</span><br><span class="line">                    response += data.decode()</span><br><span class="line">                    <span class="keyword">if</span> recv_len &lt; <span class="number">4096</span>:</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> response:</span><br><span class="line">                    <span class="built_in">print</span>(response)</span><br><span class="line">                    buffer = <span class="built_in">input</span>(<span class="string">&#x27;&gt; &#x27;</span>)</span><br><span class="line">                    buffer += <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">                    self.socket.send(buffer.encode())</span><br><span class="line">        <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;User terminated.&#x27;</span>)</span><br><span class="line">            self.socket.close()</span><br><span class="line">            sys.exit()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">listen</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;listening&#x27;</span>)</span><br><span class="line">        self.socket.bind((self.args.target, self.args.port))</span><br><span class="line">        self.socket.listen(<span class="number">5</span>)</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            client_socket, _ = self.socket.accept()</span><br><span class="line">            client_thread = threading.Thread(target=self.handle, args=(client_socket,))</span><br><span class="line">            client_thread.start()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handle</span>(<span class="params">self, client_socket</span>):</span><br><span class="line">        <span class="keyword">if</span> self.args.execute:</span><br><span class="line">            output = execute(self.args.execute)</span><br><span class="line">            client_socket.send(output.encode())</span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> self.args.upload:</span><br><span class="line">            file_buffer = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                data = client_socket.recv(<span class="number">4096</span>)</span><br><span class="line">                <span class="keyword">if</span> data:</span><br><span class="line">                    file_buffer += data</span><br><span class="line">                    <span class="built_in">print</span>(<span class="built_in">len</span>(file_buffer))</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(self.args.upload, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                f.write(file_buffer)</span><br><span class="line">            message = <span class="string">f&#x27;Saved file <span class="subst">&#123;self.args.upload&#125;</span>&#x27;</span></span><br><span class="line">            client_socket.send(message.encode())</span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> self.args.command:</span><br><span class="line">            cmd_buffer = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    client_socket.send(<span class="string">b&#x27; #&gt; &#x27;</span>)</span><br><span class="line">                    <span class="keyword">while</span> <span class="string">&#x27;\n&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> cmd_buffer.decode():</span><br><span class="line">                        cmd_buffer += client_socket.recv(<span class="number">64</span>)</span><br><span class="line">                    response = execute(cmd_buffer.decode())</span><br><span class="line">                    <span class="keyword">if</span> response:</span><br><span class="line">                        client_socket.send(response.encode())</span><br><span class="line">                    cmd_buffer = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">                <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">f&#x27;server killed <span class="subst">&#123;e&#125;</span>&#x27;</span>)</span><br><span class="line">                    self.socket.close()</span><br><span class="line">                    sys.exit()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    parser = argparse.ArgumentParser(</span><br><span class="line">        description=<span class="string">&#x27;BHP Net Tool&#x27;</span>,</span><br><span class="line">        formatter_class=argparse.RawDescriptionHelpFormatter,</span><br><span class="line">        epilog=textwrap.dedent(<span class="string">&#x27;&#x27;&#x27;Example:</span></span><br><span class="line"><span class="string">          netcat.py -t 192.168.1.108 -p 5555 -l -c # command shell</span></span><br><span class="line"><span class="string">          netcat.py -t 192.168.1.108 -p 5555 -l -u=mytest.whatisup # upload to file</span></span><br><span class="line"><span class="string">          netcat.py -t 192.168.1.108 -p 5555 -l -e=\&quot;cat /etc/passwd\&quot; # execute command</span></span><br><span class="line"><span class="string">          echo &#x27;ABCDEFGHI&#x27; | ./netcat.py -t 192.168.1.108 -p 135 # echo local text to server port 135</span></span><br><span class="line"><span class="string">          netcat.py -t 192.168.1.108 -p 5555 # connect to server</span></span><br><span class="line"><span class="string">          &#x27;&#x27;&#x27;</span>))</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;-c&#x27;</span>, <span class="string">&#x27;--command&#x27;</span>, action=<span class="string">&#x27;store_true&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;initialize command shell&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;-e&#x27;</span>, <span class="string">&#x27;--execute&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;execute specified command&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;-l&#x27;</span>, <span class="string">&#x27;--listen&#x27;</span>, action=<span class="string">&#x27;store_true&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;listen&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;-p&#x27;</span>, <span class="string">&#x27;--port&#x27;</span>, <span class="built_in">type</span>=<span class="built_in">int</span>, default=<span class="number">5555</span>, <span class="built_in">help</span>=<span class="string">&#x27;specified port&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;-t&#x27;</span>, <span class="string">&#x27;--target&#x27;</span>, default=<span class="string">&#x27;192.168.1.203&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;specified IP&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;-u&#x27;</span>, <span class="string">&#x27;--upload&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;upload file&#x27;</span>)</span><br><span class="line">    args = parser.parse_args()</span><br><span class="line">    <span class="keyword">if</span> args.listen:</span><br><span class="line">        buffer = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        buffer = sys.stdin.read()</span><br><span class="line"></span><br><span class="line">    nc = NetCat(args, buffer.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    nc.run()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>看不太懂？这好说，直接一行一行给咱解读。</p><hr><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">import</span> argparse：导入argparse模块，用于解析命令行参数。</span><br><span class="line"><span class="number">2.</span> <span class="keyword">import</span> socket：导入socket模块，用于创建套接字和网络通信。</span><br><span class="line"><span class="number">3.</span> <span class="keyword">import</span> shlex：导入shlex模块，用于解析字符串成shell单词列表。</span><br><span class="line"><span class="number">4.</span> <span class="keyword">import</span> subprocess：导入subprocess模块，用于执行外部命令。</span><br><span class="line"><span class="number">5.</span> <span class="keyword">import</span> sys：导入sys模块，用于访问系统相关的功能。</span><br><span class="line"><span class="number">6.</span> <span class="keyword">import</span> textwrap：导入textwrap模块，用于格式化文本。</span><br><span class="line"><span class="number">7.</span> <span class="keyword">def</span> <span class="title function_">execute</span>(<span class="params">cmd</span>):：定义了一个名为execute的函数，用于执行给定的命令。</span><br><span class="line"><span class="number">8.</span> cmd = cmd.strip()：去除命令字符串两端的空白字符。</span><br><span class="line"><span class="number">9.</span> <span class="keyword">if</span> <span class="keyword">not</span> cmd:：如果命令为空，则返回。</span><br><span class="line"><span class="number">10.</span> output = subprocess.check_output(shlex.split(cmd), stderr=subprocess.STDOUT)：使用subprocess模块的check_output函数执行命令，并将结果存储在output变量中。</span><br><span class="line"><span class="number">11.</span> <span class="keyword">return</span> output.decode()：将output变量解码成字符串并返回。</span><br><span class="line"><span class="number">12.</span> <span class="keyword">class</span> <span class="title class_">NetCat</span>:：定义了一个名为NetCat的类，用于实现网络通信功能。</span><br><span class="line"><span class="number">13.</span> <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, args, buffer=<span class="literal">None</span></span>):：NetCat类的初始化方法，接收args和buffer参数。</span><br><span class="line"><span class="number">14.</span> self.args = args：将参数args赋值给NetCat对象的args属性。</span><br><span class="line"><span class="number">15.</span> self.buffer = buffer：将参数buffer赋值给NetCat对象的buffer属性。</span><br><span class="line"><span class="number">16.</span> self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)：创建一个TCP套接字对象，并将其赋值给NetCat对象的socket属性。</span><br><span class="line"><span class="number">17.</span> self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)：设置套接字选项，以便允许在套接字关闭后重新使用相同的地址。</span><br><span class="line"><span class="number">18.</span> <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):：定义了一个名为run的方法，用于根据命令行参数执行不同的操作。</span><br><span class="line"><span class="number">19.</span> <span class="keyword">if</span> self.args.listen:：检查是否设置了监听模式。</span><br><span class="line"><span class="number">20.</span> self.listen()：调用listen方法开始监听操作。</span><br><span class="line"><span class="number">21.</span> self.send()：调用send方法开始发送操作。</span><br><span class="line"><span class="number">22.</span> <span class="keyword">def</span> <span class="title function_">send</span>(<span class="params">self</span>):：定义了一个名为send的方法，用于向目标主机发送数据。</span><br><span class="line"><span class="number">23.</span> self.socket.connect((self.args.target, self.args.port))：和目标主机建立TCP连接。</span><br><span class="line"><span class="number">24.</span> <span class="keyword">if</span> self.buffer:：检查是否有输入数据。</span><br><span class="line"><span class="number">25.</span> self.socket.send(self.buffer)：发送输入数据到目标主机。</span><br><span class="line"><span class="number">26.</span> <span class="keyword">while</span> <span class="literal">True</span>:：无限循环，用于持续接收和发送数据。</span><br><span class="line"><span class="number">27.</span> recv_len = <span class="number">1</span>：初始化recv_len变量为<span class="number">1</span>。</span><br><span class="line"><span class="number">28.</span> response = <span class="string">&#x27;&#x27;</span>：初始化response变量为空字符串。</span><br><span class="line"><span class="number">29.</span> <span class="keyword">while</span> recv_len:：循环接收数据，直到接收长度为<span class="number">0</span>（连接关闭）。</span><br><span class="line"><span class="number">30.</span> data = self.socket.recv(<span class="number">4096</span>)：接收最多<span class="number">4096</span>字节的数据。</span><br><span class="line"><span class="number">31.</span> recv_len = <span class="built_in">len</span>(data)：获取接收到的数据的长度。</span><br><span class="line"><span class="number">32.</span> response += data.decode()：将接收到的数据解码并添加到response变量中。</span><br><span class="line"><span class="number">33.</span> <span class="keyword">if</span> recv_len &lt; <span class="number">4096</span>:：如果接收到的数据长度小于<span class="number">4096</span>，则退出循环。</span><br><span class="line"><span class="number">34.</span> <span class="keyword">break</span>：跳出内部循环。</span><br><span class="line"><span class="number">35.</span> <span class="keyword">if</span> response:：检查是否接收到了数据。</span><br><span class="line"><span class="number">36.</span> <span class="built_in">print</span>(response)：打印接收到的数据。</span><br><span class="line"><span class="number">37.</span> buffer = <span class="built_in">input</span>(<span class="string">&#x27;&gt; &#x27;</span>)：从用户输入获取命令。</span><br><span class="line"><span class="number">38.</span> buffer += <span class="string">&#x27;\n&#x27;</span>：在命令末尾添加换行符。</span><br><span class="line"><span class="number">39.</span> self.socket.send(buffer.encode())：将命令发送给目标主机。</span><br><span class="line"><span class="number">40.</span> <span class="keyword">except</span> KeyboardInterrupt:：捕获键盘中断异常。</span><br><span class="line"><span class="number">41.</span> <span class="built_in">print</span>(<span class="string">&#x27;User terminated.&#x27;</span>)：打印用户终止信息。</span><br><span class="line"><span class="number">42.</span> self.socket.close()：关闭套接字连接。</span><br><span class="line"><span class="number">43.</span> sys.exit()：退出程序。</span><br><span class="line"><span class="number">44.</span> <span class="keyword">def</span> <span class="title function_">listen</span>(<span class="params">self</span>):：定义了一个名为listen的方法，用于开始监听连接请求。</span><br><span class="line"><span class="number">45.</span> <span class="built_in">print</span>(<span class="string">&#x27;listening&#x27;</span>)：打印监听信息。</span><br><span class="line"><span class="number">46.</span> self.socket.bind((self.args.target, self.args.port))：将套接字绑定到指定的IP地址和端口。</span><br><span class="line"><span class="number">47.</span> self.socket.listen(<span class="number">5</span>)：开始监听连接请求，允许同时最多<span class="number">5</span>个连接。</span><br><span class="line"><span class="number">48.</span> <span class="keyword">while</span> <span class="literal">True</span>:：无限循环，用于持续处理连接。</span><br><span class="line"><span class="number">49.</span> client_socket, _ = self.socket.accept()：接受客户端连接，返回客户端套接字对象和地址信息。</span><br><span class="line"><span class="number">50.</span> client_thread = threading.Thread(target=self.handle, args=(client_socket,))：创建一个新线程，用于处理客户端连接。</span><br><span class="line"><span class="number">51.</span> client_thread.start()：启动新线程。</span><br><span class="line"><span class="number">52.</span> <span class="keyword">def</span> <span class="title function_">handle</span>(<span class="params">self, client_socket</span>):：定义了一个名为handle的方法，用于处理客户端连接。</span><br><span class="line"><span class="number">53.</span> <span class="keyword">if</span> self.args.execute:：检查是否设置了执行命令参数。</span><br><span class="line"><span class="number">54.</span> output = execute(self.args.execute)：执行指定的命令，并将结果赋值给output变量。</span><br><span class="line"><span class="number">55.</span> client_socket.send(output.encode())：将命令执行结果发送回客户端。</span><br><span class="line"><span class="number">56.</span> <span class="keyword">elif</span> self.args.upload:：检查是否设置了上传文件参数。</span><br><span class="line"><span class="number">57.</span> file_buffer = <span class="string">b&#x27;&#x27;</span>：初始化file_buffer变量为空字节串。</span><br><span class="line"><span class="number">58.</span> <span class="keyword">while</span> <span class="literal">True</span>:：无限循环，用于持续接收文件数据。</span><br><span class="line"><span class="number">59.</span> data = client_socket.recv(<span class="number">4096</span>)：接收最多<span class="number">4096</span>字节的文件数据。</span><br><span class="line"><span class="number">60.</span> <span class="keyword">if</span> data:：检查是否接收到了数据。</span><br><span class="line"><span class="number">61.</span> file_buffer += data：将接收到的数据添加到file_buffer变量中。</span><br><span class="line"><span class="number">62.</span> <span class="built_in">print</span>(<span class="built_in">len</span>(file_buffer))：打印已接收文件数据的长度。</span><br><span class="line"><span class="number">63.</span> <span class="keyword">else</span>:：如果未接收到数据，跳出循环。</span><br><span class="line"><span class="number">64.</span> <span class="keyword">break</span>：跳出内部循环。</span><br><span class="line"><span class="number">65.</span> <span class="keyword">with</span> <span class="built_in">open</span>(self.args.upload, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:：以二进制写入模式打开要上传的文件。</span><br><span class="line"><span class="number">66.</span> f.write(file_buffer)：将接收到的文件数据写入文件。</span><br><span class="line"><span class="number">67.</span> message = <span class="string">f&#x27;Saved file <span class="subst">&#123;self.args.upload&#125;</span>&#x27;</span>：构造上传成功的消息。</span><br><span class="line"><span class="number">68.</span> client_socket.send(message.encode())：将上传成功的消息发送回客户端。</span><br><span class="line"><span class="number">69.</span> <span class="keyword">elif</span> self.args.command:：检查是否设置了传输命令参数。</span><br><span class="line"><span class="number">70.</span> cmd_buffer = <span class="string">b&#x27;&#x27;</span>：初始化cmd_buffer变量为空字节串，用于存储传输的命令。</span><br><span class="line"><span class="number">71.</span> <span class="keyword">while</span> <span class="literal">True</span>:：无限循环，用于持续传输命令。</span><br><span class="line"><span class="number">72.</span> client_socket.send(<span class="string">b&#x27; #&gt; &#x27;</span>)：发送命令提示符给客户端。</span><br><span class="line"><span class="number">73.</span> <span class="keyword">while</span> <span class="string">&#x27;\n&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> cmd_buffer.decode():：循环直到接收到完整的命令。</span><br><span class="line"><span class="number">74.</span> cmd_buffer += client_socket.recv(<span class="number">64</span>)：接收最多<span class="number">64</span>字节的命令数据。</span><br><span class="line"><span class="number">75.</span> response = execute(cmd_buffer.decode())：执行接收到的命令，并将结果赋值给response变量。</span><br><span class="line"><span class="number">76.</span> <span class="keyword">if</span> response:：当命令执行结果非空时。</span><br><span class="line"><span class="number">77.</span> client_socket.send(response.encode())：将命令执行结果发送给客户端。</span><br><span class="line"><span class="number">78.</span> cmd_buffer = <span class="string">b&#x27;&#x27;</span>：清空cmd_buffer变量。</span><br><span class="line"><span class="number">79.</span> <span class="built_in">print</span>(<span class="string">f&#x27;server killed <span class="subst">&#123;e&#125;</span>&#x27;</span>)：打印服务器被终止的错误信息。</span><br><span class="line"><span class="number">80.</span> self.socket.close()：关闭套接字连接。</span><br><span class="line"><span class="number">81.</span> sys.exit()：退出程序。</span><br><span class="line"><span class="number">82.</span> <span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:：如果当前模块是主程序入口。</span><br><span class="line"><span class="number">83.</span> parser = argparse.ArgumentParser(...)：创建一个命令行参数解析器。</span><br><span class="line"><span class="number">84.</span> parser.add_argument(...)：添加命令行参数选项。</span><br><span class="line"><span class="number">85.</span> args = parser.parse_args()：解析命令行参数，并将结果赋值给args变量。</span><br><span class="line"><span class="number">86.</span> <span class="keyword">if</span> args.listen:：检查是否设置了监听模式。</span><br><span class="line"><span class="number">87.</span> buffer = <span class="string">&#x27;&#x27;</span>：初始化buffer变量为空字符串。</span><br><span class="line"><span class="number">88.</span> <span class="keyword">else</span>:：如果不是监听模式。</span><br><span class="line"><span class="number">89.</span> buffer = sys.stdin.read()：从标准输入读取数据，并将结果赋值给buffer变量。</span><br><span class="line"><span class="number">90.</span> nc = NetCat(args, buffer.encode(<span class="string">&#x27;utf-8&#x27;</span>))：创建一个NetCat对象，将args和编码后的buffer作为参数传入。</span><br><span class="line"><span class="number">91.</span> nc.run()：调用NetCat对象的run方法开始执行。</span><br></pre></td></tr></table></figure><hr><p>唔唔唔，累死窝啦，拜拜！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;闲来无事，于是咱写了个python脚本，实现了瑞士军刀的功能，下面请看代码&lt;/p&gt;
&lt;figure class=&quot;highlight py&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;k</summary>
      
    
    
    
    
    <category term="python,渗透" scheme="https://qk.it-02.cf/tags/python-%E6%B8%97%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>随手写个chatgpt脚本</title>
    <link href="https://qk.it-02.cf/posts/36724/"/>
    <id>https://qk.it-02.cf/posts/36724/</id>
    <published>2023-07-07T05:15:10.000Z</published>
    <updated>2023-07-07T06:17:28.191Z</updated>
    
    <content type="html"><![CDATA[<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>在某侠上发现有个大好人发了个api，有这好事，咱必须上啊！<br>于是我一梭子下去，便有了这篇文章。话不多说我们直接开干！<br>先放张图<img src="https://img01.anheyu.com/useruploads/0/2023/07/07/64a7aa394cbe2.jpg" alt="展示"></p><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p>首先啊，咱用的是python，这是显而易见的，毕竟爬虫一事，不用它用谁。</p><hr><p>咱必须下载这几个库:<strong>requests</strong>、<strong>colorama</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install requests</span><br><span class="line">pip install colorama</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>完事之后咱便开始一把刷了</p><h1 id="写代码"><a href="#写代码" class="headerlink" title="写代码"></a>写代码</h1><p>先把库给导了再说，这可不能忘</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> colorama</span><br></pre></td></tr></table></figure><p>然后，我们开始写功能函数</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ai</span>():</span><br><span class="line">  <span class="comment"># api接口</span></span><br><span class="line">url = <span class="string">&#x27;https://api域名/api/gpt/four/?message=&#x27;</span></span><br><span class="line">resq = url + ques</span><br><span class="line">  <span class="comment"># 发出请求</span></span><br><span class="line">res = requests.get(resq,headers=&#123;<span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.81 Safari/537.36&#x27;</span>&#125;)</span><br><span class="line">  <span class="comment"># 将json响应转化为字典</span></span><br><span class="line">reply = res.json()</span><br><span class="line">  <span class="comment">#输出响应</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;智障&#x27;</span>,<span class="string">&#x27;:&#x27;</span>,reply[<span class="string">&quot;answer&quot;</span>])</span><br></pre></td></tr></table></figure><p>写入主函数</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span> :</span><br><span class="line">    <span class="comment"># 输入问题</span></span><br><span class="line">    quest = <span class="built_in">input</span>(<span class="string">&quot;我：&quot;</span>)</span><br><span class="line">    ai(quest)</span><br></pre></td></tr></table></figure><p>你以为这就结束了？看看目录！</p><h1 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h1><ul><li>现在咱确实是实现了问答这个功能，但是它是一次性的，问答结束后它就下班了。这符合咱敬业的性格吗？必须制裁！所以，咱在这用上一个<strong>while</strong>循环，这样就可以一直问答了<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># 输入问题</span></span><br><span class="line">    quest = <span class="built_in">input</span>(<span class="string">&quot;我：&quot;</span>)</span><br><span class="line">    ai(quest)</span><br></pre></td></tr></table></figure></li><li>但是，聪明又机智的咱又发现一个小问题，这确实可以一直问了，但是，咱想停了咋办？有小菜可能想说直接<strong>Ctr+c</strong>，啊这，咱得优雅一点。<br>直接内嵌一个<strong>if•••else</strong>语句，要退出，咱就<strong>break</strong><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"> <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">quest = <span class="built_in">input</span>(<span class="string">&quot;我:&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> quest == <span class="string">&#x27;退出&#x27;</span>:</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">ai(quest)</span><br></pre></td></tr></table></figure></li><li>到这里，基本就是可以了，但是咱是什么人呐，像咱这般优秀的人，那必须精益求精。so，我们在进行小小的优化一下。<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> colorama</span><br><span class="line"><span class="keyword">from</span> colorama <span class="keyword">import</span> Fore, Style</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ai</span>(<span class="params">ques</span>):</span><br><span class="line">url = <span class="string">&#x27;https://api接口/api/gpt/four/?message=&#x27;</span></span><br><span class="line">resq = url + ques</span><br><span class="line">res = requests.get(resq,headers=&#123;<span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/94.0.4606.81 Safari/537.36&#x27;</span>&#125;)</span><br><span class="line">reply = res.json()</span><br><span class="line">    <span class="comment"># 高级输出格式，支持彩色输出，看上去跟高端，直接给脚本干上去一个档次</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;\n\033[7;37m智障\033[0m&#x27;</span>,<span class="string">&#x27;:&#x27;</span>,<span class="string">&#x27;\033[4;32m%s\033[0m\n&#x27;</span>%reply[<span class="string">&quot;answer&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个一言函数，显得咱更有文采</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">yiyan</span>():</span><br><span class="line"><span class="comment"># 初始化 colorama 库</span></span><br><span class="line">colorama.init(autoreset=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 发送 GET 请求获取一言的API数据</span></span><br><span class="line">response = requests.get(<span class="string">&quot;https://v1.hitokoto.cn&quot;</span>)</span><br><span class="line"><span class="comment"># 解析 API 响应结果</span></span><br><span class="line">data = response.json()</span><br><span class="line"><span class="comment"># 提取一言内容并彩色输出</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;\n<span class="subst">&#123;Fore.YELLOW&#125;</span><span class="subst">&#123;data[<span class="string">&#x27;hitokoto&#x27;</span>]&#125;</span><span class="subst">&#123;Style.RESET_ALL&#125;</span>\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span> :</span><br><span class="line">   <span class="comment"># 亮出咱的大名，更有气势</span></span><br><span class="line">   <span class="built_in">print</span>(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">  ===================================================================</span></span><br><span class="line"><span class="string">   ██████╗ ██╗███╗   ██╗ ██████╗ ██╗  ██╗ ██████╗ ███╗   ██╗ ██████╗ </span></span><br><span class="line"><span class="string">  ██╔═══██╗██║████╗  ██║██╔════╝ ██║ ██╔╝██╔═══██╗████╗  ██║██╔════╝ </span></span><br><span class="line"><span class="string">  ██║   ██║██║██╔██╗ ██║██║  ███╗█████╔╝ ██║   ██║██╔██╗ ██║██║  ███╗</span></span><br><span class="line"><span class="string">  ██║▄▄ ██║██║██║╚██╗██║██║   ██║██╔═██╗ ██║   ██║██║╚██╗██║██║   ██║</span></span><br><span class="line"><span class="string">  ╚██████╔╝██║██║ ╚████║╚██████╔╝██║  ██╗╚██████╔╝██║ ╚████║╚██████╔╝</span></span><br><span class="line"><span class="string">   ╚══▀▀═╝ ╚═╝╚═╝  ╚═══╝ ╚═════╝ ╚═╝  ╚═╝ ╚═════╝ ╚═╝  ╚═══╝ ╚═════╝                                            </span></span><br><span class="line"><span class="string">   ===================================================================</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line">    <span class="comment"># 人性化设计，防止小菜不会退出</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;友情提示：退出请输入&#x27;退出&#x27;\n&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;清空QQ:\033[95m3186708635\033[0m\n&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;后续更新请前往清空小站:\033[94mhttps://qk.it-02.cf\033[0m&quot;</span>)</span><br><span class="line">yiyan()</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">i = <span class="built_in">input</span>(<span class="string">&quot;\033[7;92m你\033[0m:&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> i == <span class="string">&#x27;退出&#x27;</span>:</span><br><span class="line">            <span class="comment"># 走之前，咱在讲几句文化，这感觉，直接飞升</span></span><br><span class="line">yiyan()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\033[92m清空下班咯～ \033[0m&quot;</span>)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">ai(i)</span><br><span class="line"></span><br></pre></td></tr></table></figure>大功告成！</li></ul><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>api接口咱就不透露了，大伙应该都有，主要是好不容易嫖到一个，人太多，万一崩了咋办。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h1&gt;&lt;p&gt;在某侠上发现有个大好人发了个api，有这好事，咱必须上啊！&lt;br&gt;于是我一梭子下去，便有了这篇文章。话不多说我们直接开干！&lt;br&gt;先放张图&lt;</summary>
      
    
    
    
    
    <category term="python" scheme="https://qk.it-02.cf/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>中文 Falcon &amp; LLaMA &amp; OpenLLaMA 大模型</title>
    <link href="https://qk.it-02.cf/posts/63044/"/>
    <id>https://qk.it-02.cf/posts/63044/</id>
    <published>2023-07-06T12:35:10.000Z</published>
    <updated>2023-07-07T06:04:24.419Z</updated>
    
    <content type="html"><![CDATA[<h1 id="模型下载"><a href="#模型下载" class="headerlink" title="模型下载"></a>模型下载</h1><h2 id="Linly-Chinese-Falcon"><a href="#Linly-Chinese-Falcon" class="headerlink" title="Linly-Chinese-Falcon"></a>Linly-Chinese-Falcon</h2><p>Chinese-Falcon 模型在 Falcon 基础上扩充中文词表，在中英文数据上增量预训练。 模型以 <a href="https://www.apache.org/licenses/LICENSE-2.0"> Apache License 2.0 </a> 协议开源，支持商业用途。<a href="https://zhuanlan.zhihu.com/p/636994073">模型实现和训练细节</a></p><table><thead><tr><th align="left">模型下载</th><th>分类</th><th>训练数据</th><th>训练序列长度</th><th>版本</th><th align="right">更新时间</th></tr></thead><tbody><tr><td align="left"><a href="https://huggingface.co/Linly-AI/Chinese-Falcon-7B">Chinese-Falcon-7B (hf格式)</a></td><td>基础模型</td><td>50G通用语聊</td><td>2048</td><td>v0.2</td><td align="right">2023.6.15</td></tr></tbody></table><h2 id="Linly-Chinese-LLaMA"><a href="#Linly-Chinese-LLaMA" class="headerlink" title="Linly-Chinese-LLaMA"></a>Linly-Chinese-LLaMA</h2><p>Linly-Chinese-LLaMA 系列模型基于 LLaMA 权重和词表，在中文数据上增量预训练。</p><p>使用须知 ⚠️ LLaMA 原始模型权重基于 <a href="https://www.gnu.org/licenses/gpl-3.0.html"> GNU General Public License v3.0 </a>协议，仅供研究使用，不能用于商业目的。 请确认在已获得<a href="https://docs.google.com/forms/d/e/1FAIpQLSfqNECQnMkycAp2jP4Z9TFX0cGR4uf7b_fBxjY_OjhJILlKGA/viewform?usp=send_form">许可</a>的前提下使用以下模型权重。</p><table><thead><tr><th align="left">模型下载</th><th>分类</th><th>训练数据</th><th>训练序列长度</th><th>版本</th><th align="right">更新时间</th></tr></thead><tbody><tr><td align="left"><a href="https://huggingface.co/Linly-AI/Chinese-LLaMA-7B/">Chinese-LLaMA-7B</a></td><td>基础模型</td><td>100G通用语料</td><td>2048</td><td>v1.2</td><td align="right">2023.5.29</td></tr><tr><td align="left"><a href="https://huggingface.co/Linly-AI/ChatFlow-7B">ChatFlow-7B</a></td><td>对话模型</td><td>5M指令数据</td><td>1024</td><td>v1.1</td><td align="right">2023.5.14</td></tr></tbody></table><h1 id="训练情况"><a href="#训练情况" class="headerlink" title="训练情况"></a>训练情况</h1><h2 id="模型仍在迭代中，本项目定期更新模型权重。"><a href="#模型仍在迭代中，本项目定期更新模型权重。" class="headerlink" title="模型仍在迭代中，本项目定期更新模型权重。"></a>模型仍在迭代中，本项目定期更新模型权重。</h2><p><strong>Linly-Chinese-Falcon</strong></p><p><img src="https://img01.anheyu.com/useruploads/0/2023/07/06/64a6cae2a0ed3.png" alt="Linly-Chinese-Falcon"></p><p><strong>Linly-Chinese-LLaMA</strong></p><p><img src="https://img01.anheyu.com/useruploads/0/2023/07/06/64a6cbbe84ef7.png" alt="Linly-Chinese-LLaMA"></p><h1 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h1><p>本章节介绍 TencentPretrain 格式模型权重的使用方法。 下载预训练模型权重，安装依赖。</p><blockquote><p>测试环境: py3.8.12 cuda11.2.2 cudnn8.1.1.33-1 torch1.9.0 bitsandbytes0.37.2</p></blockquote><p>解码参数及详细使用说明请参考 <a href="https://github.com/ProjectD-AI/llama_inference">llama_inference</a></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git lfs install</span><br><span class="line">git <span class="built_in">clone</span> https://huggingface.co/Linly-AI/ChatFlow-7B</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/ProjectD-AI/llama_inference</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> llama_inference </span><br><span class="line">vi prompts.txt  <span class="comment">#编辑用户输入，例如&quot;上海有什么好玩的地方？&quot;</span></span><br><span class="line"></span><br><span class="line">python3 llama_infer.py --test_path prompts.txt --prediction_path result.txt  \</span><br><span class="line">                      --load_model_path ../ChatFlow-7B/chatflow_7b.bin  \</span><br><span class="line">                      --config_path config/llama_7b_config.json \</span><br><span class="line">                      --spm_model_path ../ChatFlow-7B/tokenizer.model --seq_length 512</span><br></pre></td></tr></table></figure><h2 id="多轮对话"><a href="#多轮对话" class="headerlink" title="多轮对话"></a>多轮对话</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python3 llama_dialogue.py --seq_length 512 --top_k 10   \</span><br><span class="line">                      --load_model_path ../ChatFlow-7B/chatflow_7b.bin  \</span><br><span class="line">                      --config_path ./config/llama_7b_config.json \</span><br><span class="line">                      --spm_model_path ../ChatFlow-7B/tokenizer.model</span><br></pre></td></tr></table></figure><h2 id="Int8推理加速"><a href="#Int8推理加速" class="headerlink" title="Int8推理加速"></a>Int8推理加速</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python3 llama_infer.py --test_path prompts.txt --prediction_path result.txt  \</span><br><span class="line">                      --load_model_path ../ChatFlow-7B/chatflow_7b.bin  \</span><br><span class="line">                      --config_path config/llama_7b_config.json \</span><br><span class="line">                      --spm_model_path ../ChatFlow-7B/tokenizer.model --seq_length 512 --use_int8 </span><br></pre></td></tr></table></figure><h2 id="微服务部署"><a href="#微服务部署" class="headerlink" title="微服务部署"></a>微服务部署</h2><p>安装依赖：flask</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python3 llama_server.py --load_model_path ../ChatFlow-7B/chatflow_7b.bin  \</span><br><span class="line">                        --config_path config/llama_7b_config.json \</span><br><span class="line">                        --spm_model_path ../ChatFlow-7B/tokenizer.model --seq_length 512</span><br><span class="line"></span><br><span class="line">curl -H <span class="string">&#x27;Content-Type: application/json&#x27;</span> http://127.0.0.1:8888/chat -d <span class="string">&#x27;&#123;&quot;question&quot;: &quot;北京有什么好玩的地方？&quot;&#125;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="Gradio-本地-Demo"><a href="#Gradio-本地-Demo" class="headerlink" title="Gradio 本地 Demo"></a>Gradio 本地 Demo</h2><p>安装依赖：Gradio</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python llama_gradio.py --load_model_path ../ChatFlow-7B/chatflow_7b.bin  \</span><br><span class="line">                        --config_path config/llama_7b_config.json \</span><br><span class="line">                        --spm_model_path ../ChatFlow-7B/tokenizer.model --seq_length 512</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在网页上打开：<a href="http://127.0.0.1:7860/">http://127.0.0.1:7860/</a></p><h1 id="模型训练细节"><a href="#模型训练细节" class="headerlink" title="模型训练细节"></a>模型训练细节</h1><p>模型基于 TencentPretrain 预训练和指令精调，更多详细信息参见 ➡️ <a href="https://github.com/CVI-SZU/Linly/wiki/%E5%A2%9E%E9%87%8F%E8%AE%AD%E7%BB%83">增量训练</a> ⬅️ 。</p><h1 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h1><ol><li>模型推理需要多少显存？</li></ol><blockquote><p>7B 模型约 14G，int8 模式 7G。13B 模型 28G，int8模式 14G。</p></blockquote><ol start="2"><li>训练时加载模型内存不够怎么办？</li></ol><blockquote><p>训练初始化时，每张卡会加载一个模型的拷贝，因此内存需求为模型大小*GPU数量。 内存不足时可以使用分块加载，详见<a href="https://github.com/CVI-SZU/Linly/wiki/%E6%A8%A1%E5%9E%8B%E5%88%86%E5%9D%97">模型分块</a>。</p></blockquote><ol start="3"><li>是否支持LoRA训练？</li></ol><blockquote><p>公开的模型权重没有用到 LoRA，使用全参数训练（Full-tuning）。 TencentPretrain 框架也支持 LoRA 训练，可以根据需要使用，详见 <a href="%22https://github.com/CVI-SZU/Linly/wiki/LoRA%E8%AE%AD%E7%BB%83">LoRA</a> 训练。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;模型下载&quot;&gt;&lt;a href=&quot;#模型下载&quot; class=&quot;headerlink&quot; title=&quot;模型下载&quot;&gt;&lt;/a&gt;模型下载&lt;/h1&gt;&lt;h2 id=&quot;Linly-Chinese-Falcon&quot;&gt;&lt;a href=&quot;#Linly-Chinese-Falcon&quot; cla</summary>
      
    
    
    
    
    <category term="模型" scheme="https://qk.it-02.cf/tags/%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>爬取某4K壁纸网站图片</title>
    <link href="https://qk.it-02.cf/posts/18046/"/>
    <id>https://qk.it-02.cf/posts/18046/</id>
    <published>2023-06-09T01:17:33.000Z</published>
    <updated>2023-07-07T06:03:57.515Z</updated>
    
    <content type="html"><![CDATA[<p>本次演示将向大家介绍如何使用Python编写脚本来爬取<a href="http://pic.netbian.com/">网站</a>上的图片。我们将使用requests和BeautifulSoup库来实现这个功能。请确保在运行以下代码之前已经安装了这两个库。如果没有安装，可以使用以下命令进行安装：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install requests</span><br><span class="line">pip install beautifulsoup4</span><br></pre></td></tr></table></figure><h2 id="1-导入所需库"><a href="#1-导入所需库" class="headerlink" title="1. 导入所需库"></a>1. 导入所需库</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> os</span><br></pre></td></tr></table></figure><h2 id="2-定义爬取函数"><a href="#2-定义爬取函数" class="headerlink" title="2. 定义爬取函数"></a>2. 定义爬取函数</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_html</span>(<span class="params">url</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = requests.get(url)</span><br><span class="line">        response.raise_for_status()</span><br><span class="line">        response.encoding = response.apparent_encoding</span><br><span class="line">        <span class="keyword">return</span> response.text</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;获取网页失败：&quot;</span>, e)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><h2 id="3-解析网页内容并提取图片链接"><a href="#3-解析网页内容并提取图片链接" class="headerlink" title="3. 解析网页内容并提取图片链接"></a>3. 解析网页内容并提取图片链接</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">parse_html</span>(<span class="params">html</span>):</span><br><span class="line">    soup = BeautifulSoup(html, <span class="string">&#x27;html.parser&#x27;</span>)</span><br><span class="line">    img_tags = soup.find_all(<span class="string">&#x27;img&#x27;</span>)</span><br><span class="line">    img_urls = [img[<span class="string">&#x27;src&#x27;</span>] <span class="keyword">for</span> img <span class="keyword">in</span> img_tags <span class="keyword">if</span> <span class="string">&#x27;src&#x27;</span> <span class="keyword">in</span> img.attrs]</span><br><span class="line">    <span class="keyword">return</span> img_urls</span><br></pre></td></tr></table></figure><h2 id="4-将图片下载到本地目录"><a href="#4-将图片下载到本地目录" class="headerlink" title="4. 将图片下载到本地目录"></a>4. 将图片下载到本地目录</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">download_images</span>(<span class="params">img_urls, save_dir</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(save_dir):</span><br><span class="line">        os.makedirs(save_dir)</span><br><span class="line">    <span class="keyword">for</span> img_url <span class="keyword">in</span> img_urls:</span><br><span class="line">        img_name = img_url.split(<span class="string">&#x27;/&#x27;</span>)[-<span class="number">1</span>]</span><br><span class="line">        img_path = os.path.join(save_dir, img_name)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(img_path, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                img_data = requests.get(img_url).content</span><br><span class="line">                f.write(img_data)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;img_name&#125;</span> 已下载&quot;</span>)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;下载图片失败：&quot;</span>, e)</span><br></pre></td></tr></table></figure><h2 id="5-主程序逻辑"><a href="#5-主程序逻辑" class="headerlink" title="5. 主程序逻辑"></a>5. 主程序逻辑</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    url = <span class="string">&#x27;http://pic.netbian.com/&#x27;</span></span><br><span class="line">    save_dir = <span class="string">&#x27;images&#x27;</span></span><br><span class="line">    img_urls = []</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 获取网页内容并提取图片链接</span></span><br><span class="line">    html = get_html(url)</span><br><span class="line">    img_urls = parse_html(html) <span class="keyword">if</span> html <span class="keyword">else</span> []</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 将图片下载到本地目录</span></span><br><span class="line">    download_images(img_urls, save_dir) <span class="keyword">if</span> img_urls <span class="keyword">else</span> <span class="built_in">print</span>(<span class="string">&quot;未找到图片&quot;</span>)</span><br></pre></td></tr></table></figure><p>将以上代码保存为一个名为<code>pic_downloader.py</code>的文件。然后在命令行中运行以下命令来执行脚本：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python pic_downloader.py</span><br></pre></td></tr></table></figure><p>运行成功后，你会发现一个名为<code>images</code>的文件夹被创建在当前目录下，里面包含了从<a href="http://pic.netbian.com/">网站</a>网站上爬取到的所有图片。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本次演示将向大家介绍如何使用Python编写脚本来爬取&lt;a href=&quot;http://pic.netbian.com/&quot;&gt;网站&lt;/a&gt;上的图片。我们将使用requests和BeautifulSoup库来实现这个功能。请确保在运行以下代码之前已经安装了这两个库。如果没有安装，</summary>
      
    
    
    
    
    <category term="python" scheme="https://qk.it-02.cf/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>导数的简单教学</title>
    <link href="https://qk.it-02.cf/posts/7278/"/>
    <id>https://qk.it-02.cf/posts/7278/</id>
    <published>2023-06-08T10:37:10.000Z</published>
    <updated>2023-06-08T11:42:37.901Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>导数是微积分中的一个重要概念，它描述了函数在某一点的变化率。在实际应用中，导数被广泛应用于物理、工程、经济等领域。因此，学习导数对于我们的学习和工作都非常重要。</p><h1 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h1><p>在学习导数之前，我们需要先掌握一些基本的数学知识，比如极限、连续性、微分等等。这些知识是学习导数的基础，也是后续学习的重要基础。</p><hr><p>接下来，我们来介绍一下导数的定义和计算方法。</p><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>导数的定义很简单，它表示函数在某一点的变化率。具体来说，如果函数f(x)在点x0处可导，那么它的导数f’(x0)就是函数f(x)在x0处的变化率。换句话说，f’(x0)表示当x从x0变化到x1时，函数值的变化量与自变量x的变化量的比值。</p><h1 id="计算方法"><a href="#计算方法" class="headerlink" title="计算方法"></a>计算方法</h1><p>导数的计算方法有很多种，其中最常用的是求导法则。求导法则包括链式法则、乘积法则、商法则等等。这些法则可以帮助我们快速地计算出函数在某一点或某一区间上的导数。</p><h2 id="链式法则"><a href="#链式法则" class="headerlink" title="链式法则"></a>链式法则</h2><p>指对于一个函数g(x),如果它可以表示为g(u)·v(x),其中u(x)和v(x)都是可导函数，那么g(x)在点x处的导数等于g’(u)·v’(x)。这个法则可以帮助我们将复杂的函数分解成简单的部分，从而更容易地计算导数。</p><h2 id="乘积法则"><a href="#乘积法则" class="headerlink" title="乘积法则"></a>乘积法则</h2><p>指对于两个函数f(x)和g(x),如果它们在点x处可导，那么它们的乘积f(x)g(x)在点x处的导数等于f’(x)g(x)+f(x)g’(x)。这个法则可以帮助我们计算多个函数的乘积的导数。</p><h2 id="商法则"><a href="#商法则" class="headerlink" title="商法则"></a>商法则</h2><p>指对于两个函数f(x)和g(x),如果它们在点x处可导，那么它们的商f(x)&#x2F;g(x)在点x处的导数等于[f’(x)g(x)-f(x)g’(x)]&#x2F;[g^2(x)]。这个法则可以帮助我们计算两个函数的商的导数。</p><hr><p>除了求导法则之外，还有一些特殊的函数需要特别处理。比如，常数函数、幂函数、指数函数等等。这些函数的导数可以通过一些特殊规则来计算。</p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>以下是一个示例，演示如何使用Python中的<strong>numpy</strong>库计算一个函数在给定点的导数：</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 定义一个函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> x**<span class="number">2</span> + <span class="number">2</span>*x + <span class="number">1</span></span><br><span class="line"><span class="comment"># 计算函数在点x=3处的导数</span></span><br><span class="line">x = <span class="number">3.0</span></span><br><span class="line">dx = np.gradient(f(x))[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;导数为：&quot;</span>, dx)</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">导数为： 6.000000000000001</span><br></pre></td></tr></table></figure><p>在这个示例中，我们首先定义了一个函数f(x),它返回一个二次函数的值。然后，我们使用numpy库中的gradient()函数来计算函数在点x&#x3D;3处的导数。gradient()函数返回一个包含所有导数值的一维数组，我们只需要取第一个元素即可得到一阶导数。最后，我们打印出导数值。</p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>导数在物理、工程、经济等领域都有广泛的应用。比如，在物理学中，导数可以用来描述物体的运动状态；在工程学中，导数可以用来分析系统的稳定性和响应速度；在经济学中，导数可以用来研究市场价格的变化趋势等等。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>学习导数对于我们的学习和工作都非常重要。通过掌握导数的基本概念和计算方法，我们可以更好地理解和应用微积分的知识，解决实际问题。</p>]]></content>
    
    
    <summary type="html">本文是一篇关于导数的教学文章。</summary>
    
    
    
    
    <category term="数学" scheme="https://qk.it-02.cf/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>privacy-policy</title>
    <link href="https://qk.it-02.cf/posts/46542/"/>
    <id>https://qk.it-02.cf/posts/46542/</id>
    <published>2023-06-08T08:25:05.000Z</published>
    <updated>2023-06-08T11:43:38.905Z</updated>
    
    <content type="html"><![CDATA[<h1 id="隐私政策"><a href="#隐私政策" class="headerlink" title="隐私政策"></a>隐私政策</h1><h2 id="1-什么是’清空•小站’"><a href="#1-什么是’清空•小站’" class="headerlink" title="1. 什么是’清空•小站’?"></a>1. 什么是’清空•小站’?</h2><ul><li>‘清空•小站’是由本人搭建的非盈利的博客，旨在分享合法的技术、资源</li></ul><h2 id="2-我收集哪些信息？"><a href="#2-我收集哪些信息？" class="headerlink" title="2. 我收集哪些信息？"></a>2. 我收集哪些信息？</h2><ul><li>我们会收集您在使用我们的服务时提供的信息，包括但不限于：<ul><li>您在注册账号时提供的个人信息，如姓名、邮箱地址、电话号码等；</li><li>您在使用我们的服务时产生的数据，如浏览记录、搜索记录、评论记录等；</li><li>您在使用我们的服务时提供的第三方账号信息，如微信、QQ、微博等。</li></ul></li></ul><h2 id="3-我如何使用这些信息？"><a href="#3-我如何使用这些信息？" class="headerlink" title="3. 我如何使用这些信息？"></a>3. 我如何使用这些信息？</h2><ul><li>我们会根据您的需求和授权，将这些信息用于以下方面：<ul><li>为您提供更好的服务体验；</li><li>为您推荐相关的内容；</li><li>保护您的账户安全；</li><li>遵守法律法规的要求。</li></ul></li></ul><h2 id="4-我如何保护您的隐私？"><a href="#4-我如何保护您的隐私？" class="headerlink" title="4. 我如何保护您的隐私？"></a>4. 我如何保护您的隐私？</h2><ul><li>我们会采取以下措施来保护您的隐私：<ul><li>对收集到的信息进行加密处理；</li><li>仅在必要的情况下使用您的信息；</li><li>对使用过的信息进行删除或匿名化处理；</li><li>严格控制访问权限，仅授权给需要的人员。</li></ul></li></ul><h2 id="5-如何联系我？"><a href="#5-如何联系我？" class="headerlink" title="5. 如何联系我？"></a>5. 如何联系我？</h2><ul><li>如果您对我的隐私政策有任何疑问或建议，请随时联系我们：<ul><li>邮箱：<a href="mailto:&#51;&#x31;&#56;&#x36;&#55;&#48;&#x38;&#54;&#51;&#x35;&#x40;&#x71;&#113;&#x2e;&#x63;&#111;&#x6d;">&#51;&#x31;&#56;&#x36;&#55;&#48;&#x38;&#54;&#51;&#x35;&#x40;&#x71;&#113;&#x2e;&#x63;&#111;&#x6d;</a>;</li><li>QQ：3186708635。</li></ul></li></ul><h2 id="6-您应该知道在您访问的时候不限于以下信息会被第三方获取并使用："><a href="#6-您应该知道在您访问的时候不限于以下信息会被第三方获取并使用：" class="headerlink" title="6. 您应该知道在您访问的时候不限于以下信息会被第三方获取并使用："></a>6. 您应该知道在您访问的时候不限于以下信息会被第三方获取并使用：</h2><p>第三方部分为了抵抗攻击、使用不同节点 cdn 加速等需求会收集不限于以下信息</p><!-- 在表格中添加 id 以便于通过 JavaScript 获取元素 --><table>    <thead>    <tr>        <th>类型</th>        <th>信息</th>    </tr>    </thead>    <tbody>    <tr>        <td colspan="2"><b>网络信息</b></td>    </tr>    <tr>        <td>IP地址</td>        <td><div id="userAgentIp"></div></td>    </tr>    <tr>        <td>州/大陆</td>        <td><div id="userAgentState"></div></td>    </tr>    <tr>        <td>国家</td>        <td><div id="userAgentCountry"></div></td>    </tr>    <tr>        <td>省份</td>        <td><div id="userAgentProv"></div></td>    </tr>    <tr>        <td>城市</td>        <td><div id="userAgentCity"></div></td>    </tr>    <tr>        <td>区</td>        <td><div id="userAgentDistrict"></div></td>    </tr>    <tr>        <td>运营商</td>        <td><div id="userAgentISP"></div></td>    </tr>    <tr>        <td colspan="2"><b>设备信息</b></td>    </tr>    <tr>        <td>设备</td>        <td><div id="userAgentDevice"></div></td>    </tr>    </tbody></table><!-- 在模板文件中添加 JavaScript 代码 --><script>    (async function() {    async function getIpInfo() {        var fetchUrl = "https://api.qjqq.cn/api/Local";        try {            var response = await fetch(fetchUrl);            var json = await response.json();            var ip = json.ip;            var continent = json.data.continent;            var country = json.data.country;            var prov = json.data.prov;            var city = json.data.city;            var district = json.data.district;            var isp = json.data.isp;            document.getElementById("userAgentIp").innerHTML = ip;            document.getElementById("userAgentState").innerHTML = continent;            document.getElementById("userAgentCountry").innerHTML = country;            document.getElementById("userAgentProv").innerHTML = prov;            document.getElementById("userAgentCity").innerHTML = city;            document.getElementById("userAgentDistrict").innerHTML = district;            document.getElementById("userAgentISP").innerHTML = isp;            var uaInfo = navigator.userAgent;            document.getElementById("userAgentDevice").innerHTML = uaInfo;        } catch (error) {            console.error("An error occurred while fetching IP info:", error);        }    }    await getIpInfo();})();</script><h2 id="7-我如何共享、转让您的个人信息？"><a href="#7-我如何共享、转让您的个人信息？" class="headerlink" title="7. 我如何共享、转让您的个人信息？"></a>7. 我如何共享、转让您的个人信息？</h2><p>本人不会与任何公司、组织和个人共享你的隐私信息</p><p>本人不会将你的个人信息转让给任何公司、组织和个人</p><p>第三方服务的共享、转让情况详见对应服务的隐私协议</p><h2 id="8-附属协议"><a href="#8-附属协议" class="headerlink" title="8. 附属协议"></a>8. 附属协议</h2><p>当监测到存在恶意访问、恶意请求、恶意攻击、恶意评论的行为时，为了防止增大受害范围，可能会临时将你的 ip<br>地址及访问信息短期内添加到黑名单，短期内禁止访问。</p><p>此黑名单可能被公开，并共享给其他站点（主体并非本人）使用，包括但不限于：IP 地址、设备信息、地理位置。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;隐私政策&quot;&gt;&lt;a href=&quot;#隐私政策&quot; class=&quot;headerlink&quot; title=&quot;隐私政策&quot;&gt;&lt;/a&gt;隐私政策&lt;/h1&gt;&lt;h2 id=&quot;1-什么是’清空•小站’&quot;&gt;&lt;a href=&quot;#1-什么是’清空•小站’&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
    <category term="隐私政策" scheme="https://qk.it-02.cf/tags/%E9%9A%90%E7%A7%81%E6%94%BF%E7%AD%96/"/>
    
  </entry>
  
  <entry>
    <title>Windows系统推荐和安装，简单的优化和美化以及一些软件分享</title>
    <link href="https://qk.it-02.cf/posts/5380/"/>
    <id>https://qk.it-02.cf/posts/5380/</id>
    <published>2023-06-07T10:30:00.000Z</published>
    <updated>2023-06-07T13:24:46.338Z</updated>
    
    <content type="html"><![CDATA[<p>嘿嘿，时隔不久，我又来水..啊呸，满足各位老哥们的需求了。</p><h1 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h1><p>我用的是Windsys的Windows10 LTSC2021，用了快一个月，感觉很不错，我的电脑处理器是R7 5800H，装着比Windows11流畅不少，以下是这个系统的一些简介，基本改动很少，做了一些优化和bug修复 </p><p><img src="https://image.coolapk.com/feed/2023/0606/22/9705929_fa26211e_0750_3617_791@828x812.jpeg.m.jpg"><br><img src="https://image.coolapk.com/feed/2023/0606/22/9705929_37259c42_0750_3628_747@1046x622.jpeg.m.jpg"><br><img src="https://image.coolapk.com/feed/2023/0606/22/9705929_bfdc6e3f_0750_3631_925@1168x820.jpeg.m.jpg"></p><p>俺的界面就这样的😊😊</p><p><img src="https://image.coolapk.com/feed/2023/0606/22/9705929_f2a58515_0750_3634_909@1920x1080.jpeg.m.jpg"></p><p>这个大佬也有修改的Windows11和一个自己搞的Windows11类原生方案，有兴趣的自己可以去官网看看，下面是链接<br><a href="https://windsys.win/">Windsys Project</a></p><p>这个系统里自带了一个Windsys工具箱，这里面有不少好用的工具，感觉有些很有用，大家可以自己看看呀</p><p><img src="https://image.coolapk.com/feed/2023/0606/22/9705929_8dbda29d_0750_3643_576@310x642.jpeg.m.jpg"><br><img src="https://image.coolapk.com/feed/2023/0606/22/9705929_dc4461db_0750_3646_398@296x598.jpeg.m.jpg"></p><h1 id="激活工具"><a href="#激活工具" class="headerlink" title="激活工具"></a>激活工具</h1><p>之前想装2021得时候看很多人说 LTSC 2019可以支持10年，但2021支持五年，于是找很久找到了这个激活工具，可以数字激活成lot版的，听说这个也是支持十年，也支持激活一写office等，反正很不错</p><p><img src="https://image.coolapk.com/feed/2023/0606/22/9705929_268a928f_0750_3648_214@690x464.jpeg.m.jpg"></p><h1 id="系统字体"><a href="#系统字体" class="headerlink" title="系统字体"></a>系统字体</h1><p>我的电脑是15.6寸的1080p分辨率的笔记本，微软自己的字体渲染不是很好，之前全局替换过例如大家备受好评的苹方之类的字体，但在我的1080p分辨率上显示效果甚至不如原来的，找了很久找到了这个小米兰亭字体，感觉显示效果比原来好很多，以下是在浏览器里的效果图，不知道明不明显，大家有需要可以自己试试看</p><p><img src="https://image.coolapk.com/feed/2023/0606/22/9705929_09ad3689_0750_3658_209@1918x1078.jpeg.m.jpg"><br><img src="https://image.coolapk.com/feed/2023/0606/22/9705929_b12c25db_0750_366_362@1920x1030.jpeg.m.jpg"></p><p>还有关于怎么全局替换，大家下好我分享的字体解压缩之后会得到以下的文件<br><img src="https://image.coolapk.com/feed/2023/0606/22/9705929_89c76e46_0753_204_169@1394x738.jpeg.m.jpg"></p><p>然后在PE系统下复制粘贴前三个，进入系统盘Windows Fonts文件夹替换即可，大家替换之前最好将Fonts文件夹原来的同名文件备份一下，以免后续效果不好还可以重复上面操作换回来，也防止出现bug。这里附上大佬的换字体教程</p><p><img src="https://image.coolapk.com/feed/2023/0607/04/9705929_69c3e698_5017_4463_188@1080x2400.jpeg.m.jpg"></p><h1 id="任务栏的透明美化和开始图标的更换"><a href="#任务栏的透明美化和开始图标的更换" class="headerlink" title="任务栏的透明美化和开始图标的更换"></a>任务栏的透明美化和开始图标的更换</h1><p>用的是StartlsBack这个软件，安装好之后，右击开始图标，点属性就进去软件的设置界面啦，在外观配置，自定义任务特效里可以开启任务栏透明<br><a href="https://zhutix.com/study/huan-start-orbs/">更换开始按钮 - 入门教程 - 致美化</a></p><h1 id="系统优化和日常优化的一些软件分享"><a href="#系统优化和日常优化的一些软件分享" class="headerlink" title="系统优化和日常优化的一些软件分享"></a>系统优化和日常优化的一些软件分享</h1><p>我自己也没做太多优化，就用Windsys工具箱里的WPD，自己下的wise care365，dism++简单优化了一下</p><p><img src="https://image.coolapk.com/feed/2023/0606/22/9705929_55f25c34_0753_2058_670@1190x742.jpeg.m.jpg"><br><img src="https://image.coolapk.com/feed/2023/0606/22/9705929_a819c9ad_0753_2066_271@1338x892.jpeg.m.jpg"><br><img src="https://image.coolapk.com/feed/2023/0606/22/9705929_50f29624_0753_2074_48@1238x866.jpeg.m.jpg"></p><p>然后日常清理垃圾用的就是用的Wise Care365和Dism++。没有用任何杀毒软件，我自己电脑正常用也没有啥弹窗和中病毒。平时还用了一个进程管优化理软件Process Lasso，这个软件俺也不知道作用大不大，也没测试过，反正就是一直用着了，用的是俄罗斯大佬破解的，装好后需要用工具激活一下，如果有老哥需要用这个到时候我回复一下</p><p><a href="https://image.coolapk.com/feed/2023/0606/22/9705929_a77f95f6_0753_2078_773@1424x739.jpeg.m.jpg"></a></p><p>还有就是我是拯救者电脑，Lenovo Legion Toolkit这个软件必装的，很好用，本来之前一直用联想电脑管家，后来好像听说有些内存泄露问题，而且我自己平常也只是用联想电脑管家方便打开独显直连，选择性能模式和充电模式这些，找到这个软件后就感觉联想电脑管家没啥必要了，软件很小也不占后台，不需要设置开机启动，你需要用的时候打开就行</p><p><img src="https://image.coolapk.com/feed/2023/0606/22/9705929_959ca59c_0753_2082_11@1426x930.jpeg.m.jpg"></p><p>然后就是浏览器，浏览器下了四个，最近用的比较多的也就是火狐和brave浏览器。之前一直用edge浏览器，刚开始用挺好的，用了很长时间，然后后面越来越臃肿就删除了，如果有需要删除edge浏览器的分享的软件里有一个能彻底删除edge浏览器的软件，可以试试。但不知道对Windows更新有没有影响，系统更新桌面可能还会出现图标，很烦。反正我禁用系统更新了<br>关于浏览器，第一个就是Google Chrome，这不用多说了，平常魔法出去的时候用的比较多。<br>然后是百分浏览器，现在更新比较慢，内核还在102，但用着比较顺手好用，自带了超级拖拽，鼠标手势，内存优化等功能</p><p><img src="https://image.coolapk.com/feed/2023/0606/22/9705929_218ed446_0753_209_350@1920x1030.jpeg.m.jpg"><br>直接在官网下载就行<a href="https://www.centbrowser.cn/">百分浏览器</a></p><p>火狐浏览器用的是奔跑中的奶酪修改的火狐，一直在用，灰常好用</p><p><img src="https://image.coolapk.com/feed/2023/0606/22/9705929_4c28aaef_0755_7429_408@1488x1020.jpeg.m.jpg"></p><p>想要了解更多可以去奶酪大大的官网看看，官网还有修改的chrome和edge等浏览器，也有插件推荐说明等很多有用的东西微笑微笑微笑，公众号经常也会发一些有用的教程<br><a href="https://www.runningcheese.com/">奔跑中的奶酪 - 有智，有趣，有爱</a></p><p>Brave浏览器用的是bigfoxtail大佬编译的版本，主要是删除了区块链和钱包这些东西，用的人比较少，更新的不快，目前内核还在109，反正俺一直在用，感觉还行，如果你需要可以试试</p><p><img src="https://image.coolapk.com/feed/2023/0606/22/9705929_1396c940_0755_7432_876@1506x998.jpeg.m.jpg"></p><p>最后就是一些其他自己平常用的软件分享一下吧。其实也就听歌的和浏览器等，听歌用的是洛雪音乐然后搭配上六音音源，我想听的基本都有，基本满足我日常的听歌需求了，六音音源在设置，基本设置，自定义源里加入选择就行</p><p><a href="https://image.coolapk.com/feed/2023/0606/22/9705929_55e09788_0753_2085_93@1380x890.jpeg.m.jpg"></a></p><p>小白羊云盘和mpv，小白羊云盘就是第三方阿里云盘，我主要是用这两个来看电影的，虽然有不少电影网站，但网站有时候老一卡一卡的。<br>其实我自己的也不差，操作起来也挺简单的，大家可以试试，嘿嘿。<br><a href="https://qk.it-02.cf/movies/">本博客的视频解析页面</a></p><p><img src="https://image.coolapk.com/feed/2023/0606/22/9705929_fecc9ebf_0755_7434_854@1000x752.jpeg.m.jpg"></p><p>因为阿里官方限制，现在要获取一个叫 refresh_token得东西了，才能加快下载和视频播放速度，如果有兴趣可以自己看下面链接搞一下</p><p><img src="https://image.coolapk.com/feed/2023/0606/22/9705929_d76808ff_0755_7438_806@1000x752.jpeg.m.jpg"></p><p><a href="https://alist.nn.ci/zh/guide/drivers/aliyundrive_open.html">阿里云盘 Open | AList文档</a><br>然后把点击的网盘资源就可以播放了，自带有播放器，但可以自定义，我一般用的是mpv的懒人包播放</p><p><a href="https://image.coolapk.com/feed/2023/0606/22/9705929_7083cd72_0755_7448_584@1000x752.jpeg.m.jpg"></a><br><img src="https://image.coolapk.com/feed/2023/0606/22/9705929_7a2b33b4_0755_7452_125@1000x752.jpeg.m.jpg"></p><p>好了，就这么多，不知道对多少人有帮助，反正今晚没事干写这个打发一下时间，对你有帮助就给俺点个赞吧</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;嘿嘿，时隔不久，我又来水..啊呸，满足各位老哥们的需求了。&lt;/p&gt;
&lt;h1 id=&quot;系统&quot;&gt;&lt;a href=&quot;#系统&quot; class=&quot;headerlink&quot; title=&quot;系统&quot;&gt;&lt;/a&gt;系统&lt;/h1&gt;&lt;p&gt;我用的是Windsys的Windows10 LTSC2021，用了</summary>
      
    
    
    
    
    <category term="Windows" scheme="https://qk.it-02.cf/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>test</title>
    <link href="https://qk.it-02.cf/posts/63534/"/>
    <id>https://qk.it-02.cf/posts/63534/</id>
    <published>2023-05-28T08:41:40.000Z</published>
    <updated>2023-06-07T13:23:54.298Z</updated>
    
    <content type="html"><![CDATA[<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><h2 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h2><h3 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h3><hr><ul><li>测试</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;测试&quot;&gt;&lt;a href=&quot;#测试&quot; class=&quot;headerlink&quot; title=&quot;测试&quot;&gt;&lt;/a&gt;测试&lt;/h1&gt;&lt;h2 id=&quot;测试-1&quot;&gt;&lt;a href=&quot;#测试-1&quot; class=&quot;headerlink&quot; title=&quot;测试&quot;&gt;&lt;/a&gt;测试&lt;/h2&gt;&lt;h</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>更新啦</title>
    <link href="https://qk.it-02.cf/posts/46808/"/>
    <id>https://qk.it-02.cf/posts/46808/</id>
    <published>2023-05-26T11:02:46.000Z</published>
    <updated>2023-06-07T12:47:31.342Z</updated>
    
    <content type="html"><![CDATA[<h1 id="我回来了⊙▽⊙"><a href="#我回来了⊙▽⊙" class="headerlink" title="我回来了⊙▽⊙"></a>我回来了⊙▽⊙</h1><p>好久没有更新博客了，都差点忘了有这个东西了。<br>现在想起来了，那就更新一下吧</p><hr><p>今日名言 </p><blockquote><p>如果你说“不”是认真的，就用不着再说第二次。</p></blockquote><p><img src="http://shanhe.kim/api/tu//ercy1.php" alt="今日美图"></p><hr><h1 id="更新内容"><a href="#更新内容" class="headerlink" title="更新内容"></a>更新内容</h1><p>相信细心的你肯定已经发现了，我的博客发生了很大的变化。</p><ul><li>优化了主题</li><li>新增了看板娘、音乐播放器、电子表等等</li><li>增设了留言板、壁纸、音乐、电影等页面</li></ul><h1 id="展望未来"><a href="#展望未来" class="headerlink" title="展望未来"></a>展望未来</h1><p>以后，我将继续更新博客，把博客优化得更加精致实用。</p><p>计划：</p><ul><li>进一步优化主题</li><li>优化各页面</li><li>增设功能，如评论等</li></ul><hr><p>敬请期待吧！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;我回来了⊙▽⊙&quot;&gt;&lt;a href=&quot;#我回来了⊙▽⊙&quot; class=&quot;headerlink&quot; title=&quot;我回来了⊙▽⊙&quot;&gt;&lt;/a&gt;我回来了⊙▽⊙&lt;/h1&gt;&lt;p&gt;好久没有更新博客了，都差点忘了有这个东西了。&lt;br&gt;现在想起来了，那就更新一下吧&lt;/p&gt;
&lt;hr&gt;
</summary>
      
    
    
    
    
    <category term="更新啦" scheme="https://qk.it-02.cf/tags/%E6%9B%B4%E6%96%B0%E5%95%A6/"/>
    
  </entry>
  
</feed>
